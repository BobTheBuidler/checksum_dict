def DefaultChecksumDict.__init__(self, default, seed):
    self :: dict
    default :: object
    seed :: union[dict, object, None]
    r0 :: object
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object[3]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: bool
    r12 :: dict
    r13 :: short_int
    r14 :: native_int
    r15 :: short_int
    r16 :: object
    r17 :: tuple[bool, short_int, object, object]
    r18 :: short_int
    r19 :: bool
    r20, r21, key, value :: object
    r22 :: i32
    r23, r24, r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: i32
    r30 :: bit
    r31 :: bool
    r32, r33, r34, r35 :: object
    r36 :: bool
    r37 :: object
    r38 :: bool
    r39 :: object
    r40 :: bool
    r41 :: i32
    r42, r43 :: bit
    r44 :: None
L0:
    if is_error(seed) goto L1 else goto L31
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    r1 = checksum_dict.default.globals :: static
    r2 = 'defaultdict'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L32 (error at __init__:45) else goto L3
L3:
    r4 = '__init__'
    r5 = [r3, self, default]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775811, 0)
    if is_error(r7) goto L33 (error at __init__:45) else goto L34
L4:
    dec_ref r3
    r8 = load_address PyDict_Type
    r9 = PyObject_IsInstance(seed, r8)
    r10 = r9 >= 0 :: signed
    if not r10 goto L32 (error at __init__:46) else goto L5 :: bool
L5:
    r11 = truncate r9: i32 to builtins.bool
    if r11 goto L6 else goto L12 :: bool
L6:
    r12 = cast(dict, seed)
    if is_error(r12) goto L30 (error at __init__:47) else goto L7
L7:
    r13 = 0
    r14 = PyDict_Size(r12)
    r15 = r14 << 1
    r16 = CPyDict_GetItemsIter(r12)
    if is_error(r16) goto L35 (error at __init__:47) else goto L8
L8:
    r17 = CPyDict_NextItem(r16, r13)
    r18 = r17[1]
    r13 = r18
    r19 = r17[0]
    if r19 goto L9 else goto L36 :: bool
L9:
    r20 = r17[2]
    r21 = r17[3]
    dec_ref r17
    key = r20
    value = r21
    r22 = CPyDict_SetItem(self, key, value)
    dec_ref key
    dec_ref value
    r23 = r22 >= 0 :: signed
    if not r23 goto L37 (error at __init__:48) else goto L10 :: bool
L10:
    r24 = CPyDict_CheckSize(r12, r15)
    if not r24 goto L37 (error at __init__:47) else goto L8 :: bool
L11:
    r25 = CPy_NoErrOccurred()
    if not r25 goto L30 (error at __init__:47) else goto L29 :: bool
L12:
    r26 = checksum_dict.default.globals :: static
    r27 = 'Iterable'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L32 (error at __init__:49) else goto L13
L13:
    r29 = PyObject_IsInstance(seed, r28)
    dec_ref r28
    r30 = r29 >= 0 :: signed
    if not r30 goto L32 (error at __init__:49) else goto L14 :: bool
L14:
    r31 = truncate r29: i32 to builtins.bool
    if r31 goto L15 else goto L38 :: bool
L15:
    r32 = PyObject_GetIter(seed)
    dec_ref seed
    if is_error(r32) goto L30 (error at __init__:50) else goto L16
L16:
    r33 = PyIter_Next(r32)
    if is_error(r33) goto L39 else goto L17
L17:
    r34 = PyObject_GetIter(r33)
    dec_ref r33
    if is_error(r34) goto L40 (error at __init__:50) else goto L18
L18:
    r35 = PyIter_Next(r34)
    if is_error(r35) goto L41 else goto L21
L19:
    r36 = raise ValueError('not enough values to unpack')
    if not r36 goto L30 (error at __init__:50) else goto L20 :: bool
L20:
    unreachable
L21:
    key = r35
    r37 = PyIter_Next(r34)
    if is_error(r37) goto L42 else goto L24
L22:
    r38 = raise ValueError('not enough values to unpack')
    if not r38 goto L30 (error at __init__:50) else goto L23 :: bool
L23:
    unreachable
L24:
    value = r37
    r39 = PyIter_Next(r34)
    dec_ref r34
    if is_error(r39) goto L27 else goto L43
L25:
    r40 = raise ValueError('too many values to unpack')
    if not r40 goto L30 (error at __init__:50) else goto L26 :: bool
L26:
    unreachable
L27:
    r41 = CPyDict_SetItem(self, key, value)
    dec_ref key
    dec_ref value
    r42 = r41 >= 0 :: signed
    if not r42 goto L40 (error at __init__:51) else goto L16 :: bool
L28:
    r43 = CPy_NoErrOccurred()
    if not r43 goto L30 (error at __init__:50) else goto L29 :: bool
L29:
    return 1
L30:
    r44 = <error> :: None
    return r44
L31:
    inc_ref seed
    goto L2
L32:
    dec_ref seed
    goto L30
L33:
    dec_ref seed
    dec_ref r3
    goto L30
L34:
    dec_ref r7
    goto L4
L35:
    dec_ref r12
    goto L30
L36:
    dec_ref r12
    dec_ref r16
    dec_ref r17
    goto L11
L37:
    dec_ref r12
    dec_ref r16
    goto L30
L38:
    dec_ref seed
    goto L29
L39:
    dec_ref r32
    goto L28
L40:
    dec_ref r32
    goto L30
L41:
    dec_ref r32
    dec_ref r34
    goto L19
L42:
    dec_ref key
    dec_ref r32
    dec_ref r34
    goto L22
L43:
    dec_ref key
    dec_ref value
    dec_ref r32
    dec_ref r39
    goto L25

def DefaultChecksumDict.__init____DefaultChecksumDict_glue(self, default, seed):
    self :: checksum_dict.default.DefaultChecksumDict
    default :: object
    seed :: union[dict, object, None]
    r0 :: str
    r1 :: object
    r2 :: list
    r3, r4 :: ptr
    r5 :: dict
    r6 :: bool
    r7 :: i32
    r8 :: bit
    r9 :: tuple
    r10 :: object
    r11, r12 :: None
L0:
    r0 = '__init__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L10 else goto L1
L1:
    r2 = PyList_New(1)
    if is_error(r2) goto L11 else goto L2
L2:
    r3 = get_element_ptr r2 ob_item :: PyListObject
    r4 = load_mem r3 :: ptr*
    inc_ref default
    set_mem r4, default :: builtins.object*
    r5 = PyDict_New()
    if is_error(r5) goto L12 else goto L3
L3:
    r6 = 0
    if is_error(seed) goto L5 else goto L4
L4:
    r7 = PyList_Append(r2, seed)
    r8 = r7 >= 0 :: signed
    if not r8 goto L13 else goto L6 :: bool
L5:
    r6 = 1
L6:
    r9 = PyList_AsTuple(r2)
    dec_ref r2
    if is_error(r9) goto L14 else goto L7
L7:
    r10 = PyObject_Call(r1, r9, r5)
    dec_ref r1
    dec_ref r9
    dec_ref r5
    if is_error(r10) goto L10 else goto L8
L8:
    r11 = unbox(None, r10)
    dec_ref r10
    if is_error(r11) goto L10 else goto L9
L9:
    return r11
L10:
    r12 = <error> :: None
    return r12
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r2
    goto L10
L13:
    dec_ref r1
    dec_ref r2
    dec_ref r5
    goto L10
L14:
    dec_ref r1
    dec_ref r5
    goto L10

def DefaultChecksumDict._getitem_nochecksum(self, key):
    self :: dict
    key :: object
    r0 :: i32
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11, r12 :: object
L0:
    r0 = PyDict_Contains(self, key)
    r1 = r0 >= 0 :: signed
    if not r1 goto L7 (error at _getitem_nochecksum:71) else goto L1 :: bool
L1:
    r2 = truncate r0: i32 to builtins.bool
    if r2 goto L2 else goto L4 :: bool
L2:
    r3 = CPyDict_GetItem(self, key)
    if is_error(r3) goto L7 (error at _getitem_nochecksum:72) else goto L3
L3:
    return r3
L4:
    r4 = 'default_factory'
    r5 = [self]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L7 (error at _getitem_nochecksum:73) else goto L5
L5:
    r8 = '_setitem_nochecksum'
    r9 = [self, key, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L8 (error at _getitem_nochecksum:74) else goto L9
L6:
    return r7
L7:
    r12 = <error> :: object
    return r12
L8:
    dec_ref r7
    goto L7
L9:
    dec_ref r11
    goto L6

def DefaultChecksumDict._getitem_nochecksum__DefaultChecksumDict_glue(self, key):
    self :: checksum_dict.default.DefaultChecksumDict
    key :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3, r4 :: object
L0:
    r0 = '_getitem_nochecksum'
    r1 = [self, key]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L2 else goto L1
L1:
    return r3
L2:
    r4 = <error> :: object
    return r4

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24 :: object
    r25 :: dict
    r26 :: str
    r27 :: object
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: object
    r34 :: tuple[object, object]
    r35, r36, r37 :: object
    r38 :: dict
    r39 :: str
    r40, r41 :: object
    r42 :: tuple
    r43 :: str
    r44, r45 :: object
    r46, r47 :: str
    r48 :: tuple
    r49 :: i32
    r50 :: bit
    r51 :: dict
    r52 :: str
    r53 :: i32
    r54 :: bit
    r55 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L20 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('defaultdict',)
    r6 = 'collections'
    r7 = checksum_dict.default.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L20 (error at <module>:1) else goto L4
L4:
    collections = r8 :: module
    dec_ref r8
    r9 = ('Callable', 'DefaultDict', 'Iterable', 'Optional')
    r10 = 'typing'
    r11 = checksum_dict.default.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L20 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('ChecksumAddress',)
    r14 = 'eth_typing'
    r15 = checksum_dict.default.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L20 (error at <module>:4) else goto L6
L6:
    eth_typing = r16 :: module
    dec_ref r16
    r17 = ('mypyc_attr',)
    r18 = 'mypy_extensions'
    r19 = checksum_dict.default.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L20 (error at <module>:5) else goto L7
L7:
    mypy_extensions = r20 :: module
    dec_ref r20
    r21 = ('ChecksumAddressDict', 'T', '_SeedT')
    r22 = 'checksum_dict.base'
    r23 = checksum_dict.default.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L20 (error at <module>:7) else goto L8
L8:
    checksum_dict.base = r24 :: module
    dec_ref r24
    r25 = checksum_dict.default.globals :: static
    r26 = 'DefaultDict'
    r27 = CPyDict_GetItem(r25, r26)
    if is_error(r27) goto L20 (error at <module>:11) else goto L9
L9:
    r28 = checksum_dict.default.globals :: static
    r29 = 'ChecksumAddress'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L21 (error at <module>:11) else goto L10
L10:
    r31 = checksum_dict.default.globals :: static
    r32 = 'T'
    r33 = CPyDict_GetItem(r31, r32)
    if is_error(r33) goto L22 (error at <module>:11) else goto L11
L11:
    r34 = (r30, r33)
    r35 = box(tuple[object, object], r34)
    r36 = PyObject_GetItem(r27, r35)
    dec_ref r27
    dec_ref r35
    if is_error(r36) goto L20 (error at <module>:11) else goto L12
L12:
    r37 = checksum_dict.base.ChecksumAddressDict :: type
    r38 = checksum_dict.default.globals :: static
    r39 = 'T'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L23 (error at <module>:11) else goto L13
L13:
    r41 = PyObject_GetItem(r37, r40)
    dec_ref r40
    if is_error(r41) goto L23 (error at <module>:11) else goto L14
L14:
    r42 = PyTuple_Pack(2, r36, r41)
    dec_ref r36
    dec_ref r41
    if is_error(r42) goto L20 (error at <module>:11) else goto L15
L15:
    r43 = 'checksum_dict.default'
    r44 = checksum_dict.default.DefaultChecksumDict_template :: type
    r45 = CPyType_FromTemplate(r44, r42, r43)
    dec_ref r42
    if is_error(r45) goto L20 (error at <module>:11) else goto L16
L16:
    r46 = '__mypyc_attrs__'
    r47 = '__dict__'
    r48 = PyTuple_Pack(1, r47)
    if is_error(r48) goto L24 (error at <module>:11) else goto L17
L17:
    r49 = PyObject_SetAttr(r45, r46, r48)
    dec_ref r48
    r50 = r49 >= 0 :: signed
    if not r50 goto L24 (error at <module>:11) else goto L18 :: bool
L18:
    checksum_dict.default.DefaultChecksumDict = r45 :: type
    r51 = checksum_dict.default.globals :: static
    r52 = 'DefaultChecksumDict'
    r53 = CPyDict_SetItem(r51, r52, r45)
    dec_ref r45
    r54 = r53 >= 0 :: signed
    if not r54 goto L20 (error at <module>:11) else goto L19 :: bool
L19:
    return 1
L20:
    r55 = <error> :: None
    return r55
L21:
    dec_ref r27
    goto L20
L22:
    dec_ref r27
    dec_ref r30
    goto L20
L23:
    dec_ref r36
    goto L20
L24:
    dec_ref r45
    goto L20

def ChecksumAddressDict.__init__(self, seed):
    self :: dict
    seed :: union[dict, object, None]
    r0, r1 :: object
    r2 :: i32
    r3 :: bit
    r4 :: bool
    r5 :: dict
    r6 :: short_int
    r7 :: native_int
    r8 :: short_int
    r9 :: object
    r10 :: tuple[bool, short_int, object, object]
    r11 :: short_int
    r12 :: bool
    r13, r14, key, value :: object
    r15 :: i32
    r16, r17, r18 :: bit
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25, r26, r27, r28 :: object
    r29 :: bool
    r30 :: object
    r31 :: bool
    r32 :: object
    r33 :: bool
    r34 :: i32
    r35, r36 :: bit
    r37 :: None
L0:
    if is_error(seed) goto L1 else goto L29
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    r1 = load_address PyDict_Type
    r2 = PyObject_IsInstance(seed, r1)
    r3 = r2 >= 0 :: signed
    if not r3 goto L30 (error at __init__:64) else goto L3 :: bool
L3:
    r4 = truncate r2: i32 to builtins.bool
    if r4 goto L4 else goto L10 :: bool
L4:
    r5 = cast(dict, seed)
    if is_error(r5) goto L28 (error at __init__:65) else goto L5
L5:
    r6 = 0
    r7 = PyDict_Size(r5)
    r8 = r7 << 1
    r9 = CPyDict_GetItemsIter(r5)
    if is_error(r9) goto L31 (error at __init__:65) else goto L6
L6:
    r10 = CPyDict_NextItem(r9, r6)
    r11 = r10[1]
    r6 = r11
    r12 = r10[0]
    if r12 goto L7 else goto L32 :: bool
L7:
    r13 = r10[2]
    r14 = r10[3]
    dec_ref r10
    key = r13
    value = r14
    r15 = CPyDict_SetItem(self, key, value)
    dec_ref key
    dec_ref value
    r16 = r15 >= 0 :: signed
    if not r16 goto L33 (error at __init__:66) else goto L8 :: bool
L8:
    r17 = CPyDict_CheckSize(r5, r8)
    if not r17 goto L33 (error at __init__:65) else goto L6 :: bool
L9:
    r18 = CPy_NoErrOccurred()
    if not r18 goto L28 (error at __init__:65) else goto L27 :: bool
L10:
    r19 = checksum_dict.base.globals :: static
    r20 = 'Iterable'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L30 (error at __init__:67) else goto L11
L11:
    r22 = PyObject_IsInstance(seed, r21)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L30 (error at __init__:67) else goto L12 :: bool
L12:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L13 else goto L34 :: bool
L13:
    r25 = PyObject_GetIter(seed)
    dec_ref seed
    if is_error(r25) goto L28 (error at __init__:68) else goto L14
L14:
    r26 = PyIter_Next(r25)
    if is_error(r26) goto L35 else goto L15
L15:
    r27 = PyObject_GetIter(r26)
    dec_ref r26
    if is_error(r27) goto L36 (error at __init__:68) else goto L16
L16:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L37 else goto L19
L17:
    r29 = raise ValueError('not enough values to unpack')
    if not r29 goto L28 (error at __init__:68) else goto L18 :: bool
L18:
    unreachable
L19:
    key = r28
    r30 = PyIter_Next(r27)
    if is_error(r30) goto L38 else goto L22
L20:
    r31 = raise ValueError('not enough values to unpack')
    if not r31 goto L28 (error at __init__:68) else goto L21 :: bool
L21:
    unreachable
L22:
    value = r30
    r32 = PyIter_Next(r27)
    dec_ref r27
    if is_error(r32) goto L25 else goto L39
L23:
    r33 = raise ValueError('too many values to unpack')
    if not r33 goto L28 (error at __init__:68) else goto L24 :: bool
L24:
    unreachable
L25:
    r34 = CPyDict_SetItem(self, key, value)
    dec_ref key
    dec_ref value
    r35 = r34 >= 0 :: signed
    if not r35 goto L36 (error at __init__:69) else goto L14 :: bool
L26:
    r36 = CPy_NoErrOccurred()
    if not r36 goto L28 (error at __init__:68) else goto L27 :: bool
L27:
    return 1
L28:
    r37 = <error> :: None
    return r37
L29:
    inc_ref seed
    goto L2
L30:
    dec_ref seed
    goto L28
L31:
    dec_ref r5
    goto L28
L32:
    dec_ref r5
    dec_ref r9
    dec_ref r10
    goto L9
L33:
    dec_ref r5
    dec_ref r9
    goto L28
L34:
    dec_ref seed
    goto L27
L35:
    dec_ref r25
    goto L26
L36:
    dec_ref r25
    goto L28
L37:
    dec_ref r25
    dec_ref r27
    goto L17
L38:
    dec_ref key
    dec_ref r25
    dec_ref r27
    goto L20
L39:
    dec_ref key
    dec_ref value
    dec_ref r25
    dec_ref r32
    goto L23

def ChecksumAddressDict.__init____ChecksumAddressDict_glue(self, seed):
    self :: checksum_dict.base.ChecksumAddressDict
    seed :: union[dict, object, None]
    r0 :: str
    r1 :: object
    r2 :: list
    r3 :: dict
    r4 :: bool
    r5 :: i32
    r6 :: bit
    r7 :: tuple
    r8 :: object
    r9, r10 :: None
L0:
    r0 = '__init__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L10 else goto L1
L1:
    r2 = PyList_New(0)
    if is_error(r2) goto L11 else goto L2
L2:
    r3 = PyDict_New()
    if is_error(r3) goto L12 else goto L3
L3:
    r4 = 0
    if is_error(seed) goto L5 else goto L4
L4:
    r5 = PyList_Append(r2, seed)
    r6 = r5 >= 0 :: signed
    if not r6 goto L13 else goto L6 :: bool
L5:
    r4 = 1
L6:
    r7 = PyList_AsTuple(r2)
    dec_ref r2
    if is_error(r7) goto L14 else goto L7
L7:
    r8 = PyObject_Call(r1, r7, r3)
    dec_ref r1
    dec_ref r7
    dec_ref r3
    if is_error(r8) goto L10 else goto L8
L8:
    r9 = unbox(None, r8)
    dec_ref r8
    if is_error(r9) goto L10 else goto L9
L9:
    return r9
L10:
    r10 = <error> :: None
    return r10
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r2
    goto L10
L13:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L10
L14:
    dec_ref r1
    dec_ref r3
    goto L10

def ChecksumAddressDict.__repr__(self):
    self :: dict
    r0 :: str
    r1 :: dict
    r2, r3, r4, r5 :: str
L0:
    r0 = 'ChecksumAddressDict('
    r1 = PyDict_Copy(self)
    if is_error(r1) goto L4 (error at __repr__:72) else goto L1
L1:
    r2 = PyObject_Str(r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at __repr__:72) else goto L2
L2:
    r3 = ')'
    r4 = CPyStr_Build(3, r0, r2, r3)
    dec_ref r2
    if is_error(r4) goto L4 (error at __repr__:72) else goto L3
L3:
    return r4
L4:
    r5 = <error> :: str
    return r5

def ChecksumAddressDict.__repr____ChecksumAddressDict_glue(self):
    self :: checksum_dict.base.ChecksumAddressDict
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: str
L0:
    r0 = '__repr__'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = cast(str, r3)
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: str
    return r5

def ChecksumAddressDict.__getitem__(self, key):
    self :: dict
    key, r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: tuple[object, object, object]
    r6 :: object
    r7 :: str
    r8 :: object
    r9, r10 :: bit
    r11, r12 :: object
    r13 :: str
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17 :: tuple[object, object, object]
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: bit
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: tuple
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: str
    r30 :: object
    r31 :: list
    r32 :: object
    r33 :: tuple
    r34 :: dict
    r35 :: object
    r36 :: bit
    r37 :: object
L0:
L1:
    r0 = load_address PyDict_Type
    r1 = '__getitem__'
    r2 = [r0, self, key]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L3 (error at __getitem__:78) else goto L2
L2:
    return r4
L3:
    r5 = CPy_CatchError()
    r6 = builtins :: module
    r7 = 'KeyError'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L8 (error at __getitem__:79) else goto L4
L4:
    r9 = CPy_ExceptionMatches(r8)
    dec_ref r8
    if r9 goto L7 else goto L5 :: bool
L5:
    CPy_Reraise()
    if not 0 goto L8 else goto L31 :: bool
L6:
    unreachable
L7:
    CPy_RestoreExcInfo(r5)
    dec_ref r5
    goto L10
L8:
    CPy_RestoreExcInfo(r5)
    dec_ref r5
    r10 = CPy_KeepPropagating()
    if not r10 goto L30 else goto L9 :: bool
L9:
    unreachable
L10:
    r11 = load_address PyDict_Type
    r12 = attempt_checksum(key)
    if is_error(r12) goto L13 (error at __getitem__:84) else goto L11
L11:
    r13 = '__getitem__'
    r14 = [r11, self, r12]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775811, 0)
    if is_error(r16) goto L32 (error at __getitem__:84) else goto L12
L12:
    dec_ref r12
    return r16
L13:
    r17 = CPy_CatchError()
    r18 = builtins :: module
    r19 = 'KeyError'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L28 (error at __getitem__:85) else goto L14
L14:
    r21 = CPy_ExceptionMatches(r20)
    dec_ref r20
    if r21 goto L15 else goto L26 :: bool
L15:
    r22 = CPy_GetExcValue()
    r23 = 'args'
    r24 = CPyObject_GetAttr(r22, r23)
    dec_ref r22
    if is_error(r24) goto L28 (error at __getitem__:86) else goto L16
L16:
    r25 = cast(tuple, r24)
    if is_error(r25) goto L28 (error at __getitem__:86) else goto L17
L17:
    r26 = checksum_dict.base.globals :: static
    r27 = 'exceptions'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L33 (error at __getitem__:86) else goto L18
L18:
    r29 = 'KeyError'
    r30 = CPyObject_GetAttr(r28, r29)
    dec_ref r28
    if is_error(r30) goto L33 (error at __getitem__:86) else goto L19
L19:
    r31 = PyList_New(0)
    if is_error(r31) goto L34 (error at __getitem__:86) else goto L20
L20:
    r32 = CPyList_Extend(r31, r25)
    dec_ref r25
    if is_error(r32) goto L35 (error at __getitem__:86) else goto L36
L21:
    r33 = PyList_AsTuple(r31)
    dec_ref r31
    if is_error(r33) goto L37 (error at __getitem__:86) else goto L22
L22:
    r34 = PyDict_New()
    if is_error(r34) goto L38 (error at __getitem__:86) else goto L23
L23:
    r35 = PyObject_Call(r30, r33, r34)
    dec_ref r30
    dec_ref r33
    dec_ref r34
    if is_error(r35) goto L28 (error at __getitem__:86) else goto L24
L24:
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L28 (error at __getitem__:86) else goto L39 :: bool
L25:
    unreachable
L26:
    CPy_Reraise()
    if not 0 goto L28 else goto L40 :: bool
L27:
    unreachable
L28:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    r36 = CPy_KeepPropagating()
    if not r36 goto L30 else goto L29 :: bool
L29:
    unreachable
L30:
    r37 = <error> :: object
    return r37
L31:
    dec_ref r5
    goto L6
L32:
    dec_ref r12
    goto L13
L33:
    dec_ref r25
    goto L28
L34:
    dec_ref r25
    dec_ref r30
    goto L28
L35:
    dec_ref r30
    dec_ref r31
    goto L28
L36:
    dec_ref r32
    goto L21
L37:
    dec_ref r30
    goto L28
L38:
    dec_ref r30
    dec_ref r33
    goto L28
L39:
    dec_ref r17
    goto L25
L40:
    dec_ref r17
    goto L27

def ChecksumAddressDict.__getitem____ChecksumAddressDict_glue(self, key):
    self :: checksum_dict.base.ChecksumAddressDict
    key :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3, r4 :: object
L0:
    r0 = '__getitem__'
    r1 = [self, key]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L2 else goto L1
L1:
    return r3
L2:
    r4 = <error> :: object
    return r4

def ChecksumAddressDict.__setitem__(self, key, value):
    self :: dict
    key, value :: object
    r0 :: i32
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: str
    r5 :: object[4]
    r6 :: object_ptr
    r7, r8, r9 :: object
    r10 :: str
    r11 :: object[4]
    r12 :: object_ptr
    r13 :: object
    r14 :: None
L0:
    r0 = PyDict_Contains(self, key)
    r1 = r0 >= 0 :: signed
    if not r1 goto L7 (error at __setitem__:89) else goto L1 :: bool
L1:
    r2 = truncate r0: i32 to builtins.bool
    if r2 goto L2 else goto L3 :: bool
L2:
    r3 = load_address PyDict_Type
    r4 = '__setitem__'
    r5 = [r3, self, key, value]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775812, 0)
    if is_error(r7) goto L7 (error at __setitem__:91) else goto L8
L3:
    r8 = load_address PyDict_Type
    r9 = attempt_checksum(key)
    if is_error(r9) goto L7 (error at __setitem__:93) else goto L4
L4:
    r10 = '__setitem__'
    r11 = [r8, self, r9, value]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775812, 0)
    if is_error(r13) goto L9 (error at __setitem__:93) else goto L10
L5:
    dec_ref r9
L6:
    return 1
L7:
    r14 = <error> :: None
    return r14
L8:
    dec_ref r7
    goto L6
L9:
    dec_ref r9
    goto L7
L10:
    dec_ref r13
    goto L5

def ChecksumAddressDict.__setitem____ChecksumAddressDict_glue(self, key, value):
    self :: checksum_dict.base.ChecksumAddressDict
    key, value :: object
    r0 :: str
    r1 :: object[3]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: None
L0:
    r0 = '__setitem__'
    r1 = [self, key, value]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775811, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = unbox(None, r3)
    dec_ref r3
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: None
    return r5

def ChecksumAddressDict._getitem_nochecksum(self, key):
    self :: dict
    key, r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4, r5 :: object
L0:
    r0 = load_address PyDict_Type
    r1 = '__getitem__'
    r2 = [r0, self, key]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L2 (error at _getitem_nochecksum:113) else goto L1
L1:
    return r4
L2:
    r5 = <error> :: object
    return r5

def ChecksumAddressDict._getitem_nochecksum__ChecksumAddressDict_glue(self, key):
    self :: checksum_dict.base.ChecksumAddressDict
    key :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3, r4 :: object
L0:
    r0 = '_getitem_nochecksum'
    r1 = [self, key]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L2 else goto L1
L1:
    return r3
L2:
    r4 = <error> :: object
    return r4

def ChecksumAddressDict._setitem_nochecksum(self, key, value):
    self :: dict
    key, value :: object
    r0, r1 :: str
    r2 :: object[2]
    r3 :: object_ptr
    r4 :: object
    r5 :: i32
    r6 :: bit
    r7 :: bool
    r8 :: int
    r9 :: bit
    r10, r11, r12, r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19, r20 :: object
    r21 :: str
    r22 :: object[4]
    r23 :: object_ptr
    r24 :: object
    r25 :: None
L0:
    r0 = '0x'
    r1 = 'startswith'
    r2 = [key, r0]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775810, 0)
    if is_error(r4) goto L13 (error at _setitem_nochecksum:137) else goto L1
L1:
    r5 = PyObject_IsTrue(r4)
    dec_ref r4
    r6 = r5 >= 0 :: signed
    if not r6 goto L13 (error at _setitem_nochecksum:137) else goto L2 :: bool
L2:
    r7 = truncate r5: i32 to builtins.bool
    if r7 goto L3 else goto L5 :: bool
L3:
    r8 = CPyObject_Size(key)
    if is_error(r8) goto L13 (error at _setitem_nochecksum:137) else goto L4
L4:
    r9 = r8 != 84
    dec_ref r8 :: int
    if r9 goto L5 else goto L11 :: bool
L5:
    r10 = "'"
    r11 = PyObject_Str(key)
    if is_error(r11) goto L13 (error at _setitem_nochecksum:138) else goto L6
L6:
    r12 = "' is not a valid ETH address"
    r13 = CPyStr_Build(3, r10, r11, r12)
    dec_ref r11
    if is_error(r13) goto L13 (error at _setitem_nochecksum:138) else goto L7
L7:
    r14 = builtins :: module
    r15 = 'ValueError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L14 (error at _setitem_nochecksum:138) else goto L8
L8:
    r17 = [r13]
    r18 = load_address r17
    r19 = _PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L14 (error at _setitem_nochecksum:138) else goto L9
L9:
    dec_ref r13
    CPy_Raise(r19)
    dec_ref r19
    if not 0 goto L13 (error at _setitem_nochecksum:138) else goto L10 :: bool
L10:
    unreachable
L11:
    r20 = load_address PyDict_Type
    r21 = '__setitem__'
    r22 = [r20, self, key, value]
    r23 = load_address r22
    r24 = PyObject_VectorcallMethod(r21, r23, 9223372036854775812, 0)
    if is_error(r24) goto L13 (error at _setitem_nochecksum:139) else goto L15
L12:
    return 1
L13:
    r25 = <error> :: None
    return r25
L14:
    dec_ref r13
    goto L13
L15:
    dec_ref r24
    goto L12

def ChecksumAddressDict._setitem_nochecksum__ChecksumAddressDict_glue(self, key, value):
    self :: checksum_dict.base.ChecksumAddressDict
    key, value :: object
    r0 :: str
    r1 :: object[3]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: None
L0:
    r0 = '_setitem_nochecksum'
    r1 = [self, key, value]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775811, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = unbox(None, r3)
    dec_ref r3
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: None
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: dict
    r37 :: str
    r38 :: i32
    r39 :: bit
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: object
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: tuple[object, object]
    r53, r54 :: object
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: tuple[object, object]
    r68, r69, r70 :: object
    r71 :: tuple[object, object]
    r72, r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: i32
    r77 :: bit
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: dict
    r82 :: str
    r83 :: object
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: tuple[object, object]
    r88, r89 :: object
    r90 :: tuple
    r91 :: str
    r92, r93 :: object
    r94, r95 :: str
    r96 :: tuple
    r97 :: i32
    r98 :: bit
    r99 :: dict
    r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L35 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Dict', 'Iterable', 'Optional', 'Tuple', 'TypeVar', 'Union', 'overload')
    r6 = 'typing'
    r7 = checksum_dict.base.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L35 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ChecksumAddress',)
    r10 = 'eth_typing'
    r11 = checksum_dict.base.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L35 (error at <module>:3) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('mypyc_attr',)
    r14 = 'mypy_extensions'
    r15 = checksum_dict.base.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L35 (error at <module>:4) else goto L6
L6:
    mypy_extensions = r16 :: module
    dec_ref r16
    r17 = ('exceptions',)
    r18 = 'checksum_dict'
    r19 = checksum_dict.base.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L35 (error at <module>:6) else goto L7
L7:
    checksum_dict = r20 :: module
    dec_ref r20
    r21 = ('AnyAddressOrContract',)
    r22 = 'checksum_dict._typing'
    r23 = checksum_dict.base.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L35 (error at <module>:7) else goto L8
L8:
    checksum_dict._typing = r24 :: module
    dec_ref r24
    r25 = ('attempt_checksum',)
    r26 = 'checksum_dict._utils'
    r27 = checksum_dict.base.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L35 (error at <module>:8) else goto L9
L9:
    checksum_dict._utils = r28 :: module
    dec_ref r28
    r29 = 'T'
    r30 = checksum_dict.base.globals :: static
    r31 = 'TypeVar'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L35 (error at <module>:11) else goto L10
L10:
    r33 = [r29]
    r34 = load_address r33
    r35 = _PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L35 (error at <module>:11) else goto L11
L11:
    r36 = checksum_dict.base.globals :: static
    r37 = 'T'
    r38 = CPyDict_SetItem(r36, r37, r35)
    dec_ref r35
    r39 = r38 >= 0 :: signed
    if not r39 goto L35 (error at <module>:11) else goto L12 :: bool
L12:
    r40 = checksum_dict.base.globals :: static
    r41 = 'Union'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L35 (error at <module>:13) else goto L13
L13:
    r43 = checksum_dict.base.globals :: static
    r44 = 'Dict'
    r45 = CPyDict_GetItem(r43, r44)
    if is_error(r45) goto L36 (error at <module>:13) else goto L14
L14:
    r46 = checksum_dict.base.globals :: static
    r47 = 'AnyAddressOrContract'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L37 (error at <module>:13) else goto L15
L15:
    r49 = checksum_dict.base.globals :: static
    r50 = 'T'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L38 (error at <module>:13) else goto L16
L16:
    r52 = (r48, r51)
    r53 = box(tuple[object, object], r52)
    r54 = PyObject_GetItem(r45, r53)
    dec_ref r45
    dec_ref r53
    if is_error(r54) goto L36 (error at <module>:13) else goto L17
L17:
    r55 = checksum_dict.base.globals :: static
    r56 = 'Iterable'
    r57 = CPyDict_GetItem(r55, r56)
    if is_error(r57) goto L39 (error at <module>:13) else goto L18
L18:
    r58 = checksum_dict.base.globals :: static
    r59 = 'Tuple'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L40 (error at <module>:13) else goto L19
L19:
    r61 = checksum_dict.base.globals :: static
    r62 = 'AnyAddressOrContract'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L41 (error at <module>:13) else goto L20
L20:
    r64 = checksum_dict.base.globals :: static
    r65 = 'T'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L42 (error at <module>:13) else goto L21
L21:
    r67 = (r63, r66)
    r68 = box(tuple[object, object], r67)
    r69 = PyObject_GetItem(r60, r68)
    dec_ref r60
    dec_ref r68
    if is_error(r69) goto L40 (error at <module>:13) else goto L22
L22:
    r70 = PyObject_GetItem(r57, r69)
    dec_ref r57
    dec_ref r69
    if is_error(r70) goto L39 (error at <module>:13) else goto L23
L23:
    r71 = (r54, r70)
    r72 = box(tuple[object, object], r71)
    r73 = PyObject_GetItem(r42, r72)
    dec_ref r42
    dec_ref r72
    if is_error(r73) goto L35 (error at <module>:13) else goto L24
L24:
    r74 = checksum_dict.base.globals :: static
    r75 = '_SeedT'
    r76 = CPyDict_SetItem(r74, r75, r73)
    dec_ref r73
    r77 = r76 >= 0 :: signed
    if not r77 goto L35 (error at <module>:13) else goto L25 :: bool
L25:
    r78 = checksum_dict.base.globals :: static
    r79 = 'Dict'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L35 (error at <module>:17) else goto L26
L26:
    r81 = checksum_dict.base.globals :: static
    r82 = 'ChecksumAddress'
    r83 = CPyDict_GetItem(r81, r82)
    if is_error(r83) goto L43 (error at <module>:17) else goto L27
L27:
    r84 = checksum_dict.base.globals :: static
    r85 = 'T'
    r86 = CPyDict_GetItem(r84, r85)
    if is_error(r86) goto L44 (error at <module>:17) else goto L28
L28:
    r87 = (r83, r86)
    r88 = box(tuple[object, object], r87)
    r89 = PyObject_GetItem(r80, r88)
    dec_ref r80
    dec_ref r88
    if is_error(r89) goto L35 (error at <module>:17) else goto L29
L29:
    r90 = PyTuple_Pack(1, r89)
    dec_ref r89
    if is_error(r90) goto L35 (error at <module>:17) else goto L30
L30:
    r91 = 'checksum_dict.base'
    r92 = checksum_dict.base.ChecksumAddressDict_template :: type
    r93 = CPyType_FromTemplate(r92, r90, r91)
    dec_ref r90
    if is_error(r93) goto L35 (error at <module>:17) else goto L31
L31:
    r94 = '__mypyc_attrs__'
    r95 = '__dict__'
    r96 = PyTuple_Pack(1, r95)
    if is_error(r96) goto L45 (error at <module>:17) else goto L32
L32:
    r97 = PyObject_SetAttr(r93, r94, r96)
    dec_ref r96
    r98 = r97 >= 0 :: signed
    if not r98 goto L45 (error at <module>:17) else goto L33 :: bool
L33:
    checksum_dict.base.ChecksumAddressDict = r93 :: type
    r99 = checksum_dict.base.globals :: static
    r100 = 'ChecksumAddressDict'
    r101 = CPyDict_SetItem(r99, r100, r93)
    dec_ref r93
    r102 = r101 >= 0 :: signed
    if not r102 goto L35 (error at <module>:17) else goto L34 :: bool
L34:
    return 1
L35:
    r103 = <error> :: None
    return r103
L36:
    dec_ref r42
    goto L35
L37:
    dec_ref r42
    dec_ref r45
    goto L35
L38:
    dec_ref r42
    dec_ref r45
    dec_ref r48
    goto L35
L39:
    dec_ref r42
    dec_ref r54
    goto L35
L40:
    dec_ref r42
    dec_ref r54
    dec_ref r57
    goto L35
L41:
    dec_ref r42
    dec_ref r54
    dec_ref r57
    dec_ref r60
    goto L35
L42:
    dec_ref r42
    dec_ref r54
    dec_ref r57
    dec_ref r60
    dec_ref r63
    goto L35
L43:
    dec_ref r80
    goto L35
L44:
    dec_ref r80
    dec_ref r83
    goto L35
L45:
    dec_ref r93
    goto L35

def attempt_checksum(value):
    value :: union[str, bytes, object]
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, r6, r7 :: object
    r8 :: bit
    r9 :: object
    r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: union[object, str]
    r15 :: str
    r16 :: object
    r17 :: bool
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: bool
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: str
    r27, r28 :: object
    r29 :: str
    r30 :: object[1]
    r31 :: object_ptr
    r32 :: object
    r33 :: union[object, str]
    r34 :: str
    r35, r36 :: object
L0:
    r0 = load_address PyUnicode_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L27 (error at attempt_checksum:30) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L5 :: bool
L2:
    inc_ref value
    r4 = cast(str, value)
    if is_error(r4) goto L27 (error at attempt_checksum:31) else goto L3
L3:
    r5 = checksum_or_raise(r4)
    dec_ref r4
    if is_error(r5) goto L27 (error at attempt_checksum:31) else goto L4
L4:
    return r5
L5:
    r6 = PyObject_Type(value)
    inc_ref r6
    r7 = load_address PyBytes_Type
    r8 = r6 == r7
    dec_ref r6
    if r8 goto L28 else goto L11 :: bool
L6:
    inc_ref value
    r9 = value
    r10 = 'hex'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L29 (error at attempt_checksum:33) else goto L7
L7:
    dec_ref r9
    r14 = r13
L8:
    r15 = cast(str, r14)
    if is_error(r15) goto L27 (error at attempt_checksum:33) else goto L9
L9:
    r16 = checksum_or_raise(r15)
    dec_ref r15
    if is_error(r16) goto L27 (error at attempt_checksum:33) else goto L10
L10:
    return r16
L11:
    r17 = _type_has_checksum_addr(r6)
    if is_error(r17) goto L30 (error at attempt_checksum:34) else goto L12
L12:
    if r17 goto L31 else goto L16 :: bool
L13:
    inc_ref value
    r18 = value
    r19 = 'address'
    r20 = CPyObject_GetAttr(r18, r19)
    dec_ref r18
    if is_error(r20) goto L27 (error at attempt_checksum:35) else goto L14
L14:
L15:
    return r20
L16:
    r21 = 'address'
    r22 = PyObject_HasAttr(r6, r21)
    dec_ref r6
    if r22 goto L17 else goto L22 :: bool
L17:
    inc_ref value
    r23 = value
    r24 = 'address'
    r25 = CPyObject_GetAttr(r23, r24)
    dec_ref r23
    if is_error(r25) goto L27 (error at attempt_checksum:37) else goto L18
L18:
L19:
    r26 = cast(str, r25)
    if is_error(r26) goto L27 (error at attempt_checksum:37) else goto L20
L20:
    r27 = checksum_or_raise(r26)
    dec_ref r26
    if is_error(r27) goto L27 (error at attempt_checksum:37) else goto L21
L21:
    return r27
L22:
    inc_ref value
    r28 = value
    r29 = 'hex'
    r30 = [r28]
    r31 = load_address r30
    r32 = PyObject_VectorcallMethod(r29, r31, 9223372036854775809, 0)
    if is_error(r32) goto L32 (error at attempt_checksum:39) else goto L23
L23:
    dec_ref r28
    r33 = r32
L24:
    r34 = cast(str, r33)
    if is_error(r34) goto L27 (error at attempt_checksum:39) else goto L25
L25:
    r35 = checksum_or_raise(r34)
    dec_ref r34
    if is_error(r35) goto L27 (error at attempt_checksum:39) else goto L26
L26:
    return r35
L27:
    r36 = <error> :: object
    return r36
L28:
    dec_ref r6
    goto L6
L29:
    dec_ref r9
    goto L27
L30:
    dec_ref r6
    goto L27
L31:
    dec_ref r6
    goto L13
L32:
    dec_ref r28
    goto L27

def checksum_or_raise(string):
    string :: str
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: bit
    r11 :: object
    r12, r13, r14 :: str
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21 :: bit
    r22 :: object
L0:
L1:
    r0 = checksum_dict._utils.globals :: static
    r1 = 'to_checksum_address'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L4 (error at checksum_or_raise:44) else goto L2
L2:
    r3 = [string]
    r4 = load_address r3
    r5 = _PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at checksum_or_raise:44) else goto L3
L3:
    return r5
L4:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'ValueError'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L13 (error at checksum_or_raise:45) else goto L5
L5:
    r10 = CPy_ExceptionMatches(r9)
    dec_ref r9
    if r10 goto L6 else goto L11 :: bool
L6:
    r11 = CPy_GetExcValue()
    dec_ref r11
    r12 = "'"
    r13 = "' is not a valid ETH address"
    r14 = CPyStr_Build(3, r12, string, r13)
    if is_error(r14) goto L13 (error at checksum_or_raise:46) else goto L7
L7:
    r15 = builtins :: module
    r16 = 'ValueError'
    r17 = CPyObject_GetAttr(r15, r16)
    if is_error(r17) goto L16 (error at checksum_or_raise:46) else goto L8
L8:
    r18 = [r14]
    r19 = load_address r18
    r20 = _PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L16 (error at checksum_or_raise:46) else goto L9
L9:
    dec_ref r14
    CPy_Raise(r20)
    dec_ref r20
    if not 0 goto L13 (error at checksum_or_raise:46) else goto L17 :: bool
L10:
    unreachable
L11:
    CPy_Reraise()
    if not 0 goto L13 else goto L18 :: bool
L12:
    unreachable
L13:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r21 = CPy_KeepPropagating()
    if not r21 goto L15 else goto L14 :: bool
L14:
    unreachable
L15:
    r22 = <error> :: object
    return r22
L16:
    dec_ref r14
    goto L13
L17:
    dec_ref r6
    goto L10
L18:
    dec_ref r6
    goto L12

def _type_has_checksum_addr(typ):
    typ :: object
    r0 :: dict
    r1 :: bool
    r2 :: object
    r3, has_checksum_addr :: union[bool, None]
    r4 :: object
    r5 :: bit
    r6 :: set
    r7 :: str
    r8 :: object
    r9 :: str
    r10 :: i32
    r11 :: bit
    r12, r13 :: bool
    r14 :: set
    r15 :: str
    r16 :: object
    r17, r18 :: str
    r19 :: list
    r20 :: object
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: object
    r26 :: bool
    r27 :: dict
    r28 :: bool
    r29 :: object
    r30 :: i32
    r31 :: bit
    r32, r33 :: bool
L0:
    r0 = checksum_dict._utils._KNOWN_CHECKSUMMED_TYPES :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_KNOWN_CHECKSUMMED_TYPES" was not set')
    if not r1 goto L25 (error at _type_has_checksum_addr:50) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = CPyDict_GetWithNone(r0, typ)
    if is_error(r2) goto L25 (error at _type_has_checksum_addr:50) else goto L4
L4:
    r3 = cast(union[bool, None], r2)
    if is_error(r3) goto L25 (error at _type_has_checksum_addr:50) else goto L5
L5:
    has_checksum_addr = r3
    r4 = load_address _Py_NoneStruct
    r5 = has_checksum_addr == r4
    if r5 goto L26 else goto L23 :: bool
L6:
    r6 = frozenset({'Contract', 'ERC20'})
    r7 = '__name__'
    r8 = CPyObject_GetAttr(typ, r7)
    if is_error(r8) goto L25 (error at _type_has_checksum_addr:52) else goto L7
L7:
    r9 = cast(str, r8)
    if is_error(r9) goto L25 (error at _type_has_checksum_addr:52) else goto L8
L8:
    r10 = PySet_Contains(r6, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L25 (error at _type_has_checksum_addr:52) else goto L9 :: bool
L9:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L11 else goto L10 :: bool
L10:
    r13 = r12
    goto L18
L11:
    r14 = frozenset({'brownie', 'dank_mids', 'y'})
    r15 = '__module__'
    r16 = CPyObject_GetAttr(typ, r15)
    if is_error(r16) goto L25 (error at _type_has_checksum_addr:52) else goto L12
L12:
    r17 = cast(str, r16)
    if is_error(r17) goto L25 (error at _type_has_checksum_addr:52) else goto L13
L13:
    r18 = '.'
    r19 = PyUnicode_Split(r17, r18, -1)
    dec_ref r17
    if is_error(r19) goto L25 (error at _type_has_checksum_addr:52) else goto L14
L14:
    r20 = CPyList_GetItemShort(r19, 0)
    dec_ref r19
    if is_error(r20) goto L25 (error at _type_has_checksum_addr:52) else goto L15
L15:
    r21 = cast(str, r20)
    if is_error(r21) goto L25 (error at _type_has_checksum_addr:52) else goto L16
L16:
    r22 = PySet_Contains(r14, r21)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L25 (error at _type_has_checksum_addr:52) else goto L17 :: bool
L17:
    r24 = truncate r22: i32 to builtins.bool
    r13 = r24
L18:
    r25 = box(bool, r13)
    inc_ref r25
    has_checksum_addr = r25
    r26 = unbox(bool, has_checksum_addr)
    if is_error(r26) goto L27 (error at _type_has_checksum_addr:55) else goto L19
L19:
    r27 = checksum_dict._utils._KNOWN_CHECKSUMMED_TYPES :: static
    if is_error(r27) goto L28 else goto L22
L20:
    r28 = raise NameError('value for final name "_KNOWN_CHECKSUMMED_TYPES" was not set')
    if not r28 goto L25 (error at _type_has_checksum_addr:55) else goto L21 :: bool
L21:
    unreachable
L22:
    r29 = box(bool, r26)
    r30 = CPyDict_SetItem(r27, typ, r29)
    r31 = r30 >= 0 :: signed
    if not r31 goto L27 (error at _type_has_checksum_addr:55) else goto L23 :: bool
L23:
    r32 = unbox(bool, has_checksum_addr)
    dec_ref has_checksum_addr
    if is_error(r32) goto L25 (error at _type_has_checksum_addr:56) else goto L24
L24:
    return r32
L25:
    r33 = <error> :: bool
    return r33
L26:
    dec_ref has_checksum_addr
    goto L6
L27:
    dec_ref has_checksum_addr
    goto L25
L28:
    dec_ref has_checksum_addr
    goto L20

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27, r28 :: dict
    r29 :: str
    r30 :: i32
    r31 :: bit
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: i32
    r40 :: bit
    r41 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L14 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Dict', 'Final', 'Type', 'Union')
    r6 = 'typing'
    r7 = checksum_dict._utils.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L14 (error at <module>:7) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address cchecksum :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [9]
    r13 = load_address r12
    r14 = (('cchecksum', 'cchecksum', 'cchecksum'),)
    r15 = checksum_dict._utils.globals :: static
    r16 = 'checksum_dict/_utils.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L14 else goto L5 :: bool
L5:
    r19 = ('ChecksumAddress',)
    r20 = 'eth_typing'
    r21 = checksum_dict._utils.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L14 (error at <module>:10) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('_typing',)
    r24 = 'checksum_dict'
    r25 = checksum_dict._utils.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L14 (error at <module>:12) else goto L7
L7:
    checksum_dict = r26 :: module
    dec_ref r26
    if 0 goto L8 else goto L8 :: bool
L8:
    r27 = PyDict_New()
    if is_error(r27) goto L14 (error at <module>:22) else goto L9
L9:
    checksum_dict._utils._KNOWN_CHECKSUMMED_TYPES = r27 :: static
    r28 = checksum_dict._utils.globals :: static
    r29 = '_KNOWN_CHECKSUMMED_TYPES'
    r30 = CPyDict_SetItem(r28, r29, r27)
    dec_ref r27
    r31 = r30 >= 0 :: signed
    if not r31 goto L14 (error at <module>:22) else goto L10 :: bool
L10:
    r32 = checksum_dict._utils.globals :: static
    r33 = 'cchecksum'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L14 (error at <module>:25) else goto L11
L11:
    r35 = 'to_checksum_address'
    r36 = CPyObject_GetAttr(r34, r35)
    dec_ref r34
    if is_error(r36) goto L14 (error at <module>:25) else goto L12
L12:
    r37 = checksum_dict._utils.globals :: static
    r38 = 'to_checksum_address'
    r39 = CPyDict_SetItem(r37, r38, r36)
    dec_ref r36
    r40 = r39 >= 0 :: signed
    if not r40 goto L14 (error at <module>:25) else goto L13 :: bool
L13:
    return 1
L14:
    r41 = <error> :: None
    return r41
